/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/common/schematics/utils/utils", ["require", "exports", "@angular-devkit/schematics", "@schematics/angular/utility/workspace", "typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const schematics_1 = require("@angular-devkit/schematics");
    const workspace_1 = require("@schematics/angular/utility/workspace");
    const ts = require("typescript");
    function getProject(host, projectName) {
        return __awaiter(this, void 0, void 0, function* () {
            const workspace = yield workspace_1.getWorkspace(host);
            const project = workspace.projects.get(projectName);
            if (!project || project.extensions.projectType !== 'application') {
                throw new schematics_1.SchematicsException(`Universal requires a project type of 'application'.`);
            }
            return project;
        });
    }
    exports.getProject = getProject;
    function stripTsExtension(file) {
        return file.replace(/\.ts$/, '');
    }
    exports.stripTsExtension = stripTsExtension;
    function getOutputPath(host, projectName, target) {
        return __awaiter(this, void 0, void 0, function* () {
            // Generate new output paths
            const project = yield getProject(host, projectName);
            const serverTarget = project.targets.get(target);
            if (!serverTarget || !serverTarget.options) {
                throw new schematics_1.SchematicsException(`Cannot find 'options' for ${projectName} ${target} target.`);
            }
            const { outputPath } = serverTarget.options;
            if (typeof outputPath !== 'string') {
                throw new schematics_1.SchematicsException(`outputPath for ${projectName} ${target} target is not a string.`);
            }
            return outputPath;
        });
    }
    exports.getOutputPath = getOutputPath;
    function findImport(sourceFile, moduleName, symbolName) {
        // Only look through the top-level imports.
        for (const node of sourceFile.statements) {
            if (!ts.isImportDeclaration(node) || !ts.isStringLiteral(node.moduleSpecifier) ||
                node.moduleSpecifier.text !== moduleName) {
                continue;
            }
            const namedBindings = node.importClause && node.importClause.namedBindings;
            if (!namedBindings || !ts.isNamedImports(namedBindings)) {
                continue;
            }
            if (namedBindings.elements.some(element => element.name.text === symbolName)) {
                return namedBindings;
            }
        }
        return null;
    }
    exports.findImport = findImport;
    /** Gets import information about the specified identifier by using the Type checker. */
    function getImportOfIdentifier(typeChecker, node) {
        const symbol = typeChecker.getSymbolAtLocation(node);
        if (!symbol || !symbol.declarations.length) {
            return null;
        }
        const decl = symbol.declarations[0];
        if (!ts.isImportSpecifier(decl)) {
            return null;
        }
        const importDecl = decl.parent.parent.parent;
        if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {
            return null;
        }
        return {
            // Handles aliased imports: e.g. "import {Component as myComp} from ...";
            name: decl.propertyName ? decl.propertyName.text : decl.name.text,
            importModule: importDecl.moduleSpecifier.text,
            node: importDecl
        };
    }
    exports.getImportOfIdentifier = getImportOfIdentifier;
    function addInitialNavigation(node) {
        const existingOptions = node.arguments[1];
        // If the user has explicitly set initialNavigation, we respect that
        if (existingOptions && existingOptions.properties.some(exp => ts.isPropertyAssignment(exp) && ts.isIdentifier(exp.name) &&
            exp.name.text === 'initialNavigation')) {
            return node;
        }
        const enabledLiteral = ts.createStringLiteral('enabled');
        // TypeScript will emit the Node with double quotes.
        // In schematics we usually write code with a single quotes
        // tslint:disable-next-line: no-any
        enabledLiteral.singleQuote = true;
        const initialNavigationProperty = ts.createPropertyAssignment('initialNavigation', enabledLiteral);
        const routerOptions = existingOptions
            ? ts.updateObjectLiteral(existingOptions, ts.createNodeArray([
                ...existingOptions.properties,
                initialNavigationProperty
            ]))
            : ts.createObjectLiteral([initialNavigationProperty], true);
        const args = [node.arguments[0], routerOptions];
        return ts.createCall(node.expression, node.typeArguments, args);
    }
    exports.addInitialNavigation = addInitialNavigation;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2NvbW1vbi9zY2hlbWF0aWNzL3V0aWxzL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBR0gsMkRBQWlFO0lBRWpFLHFFQUFxRTtJQUNyRSxpQ0FBaUM7SUFFakMsU0FBc0IsVUFBVSxDQUM5QixJQUFVLEVBQ1YsV0FBbUI7O1lBRW5CLE1BQU0sU0FBUyxHQUFHLE1BQU0sd0JBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMzQyxNQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUVwRCxJQUFJLENBQUMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsV0FBVyxLQUFLLGFBQWEsRUFBRTtnQkFDaEUsTUFBTSxJQUFJLGdDQUFtQixDQUFDLHFEQUFxRCxDQUFDLENBQUM7YUFDdEY7WUFFRCxPQUFPLE9BQU8sQ0FBQztRQUNqQixDQUFDO0tBQUE7SUFaRCxnQ0FZQztJQUVELFNBQWdCLGdCQUFnQixDQUFDLElBQVk7UUFDM0MsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRkQsNENBRUM7SUFFRCxTQUFzQixhQUFhLENBQ2pDLElBQVUsRUFDVixXQUFtQixFQUNuQixNQUEwQjs7WUFFMUIsNEJBQTRCO1lBQzVCLE1BQU0sT0FBTyxHQUFHLE1BQU0sVUFBVSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztZQUNwRCxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNqRCxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRTtnQkFDMUMsTUFB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LENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7WUFDekQsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssbUJBQW1CLENBQUMsRUFBRTtZQUN4QyxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsTUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3pELG9EQUFvRDtRQUNwRCwyREFBMkQ7UUFDM0QsbUNBQW1DO1FBQ2xDLGNBQXNCLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUUzQyxNQUFNLHlCQUF5QixHQUMzQixFQUFFLENBQUMsd0JBQXdCLENBQUMsbUJBQW1CLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDckUsTUFBTSxhQUFhLEdBQUcsZUFBZTtZQUNuQyxDQUFDLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDO2dCQUMzRCxHQUFHLGVBQWUsQ0FBQyxVQUFVO2dCQUM3Qix5QkFBeUI7YUFDMUIsQ0FBQyxDQUFDO1lBQ0gsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLHlCQUF5QixDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDOUQsTUFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBRWhELE9BQU8sRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQTNCRCxvREEyQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHsgd29ya3NwYWNlcyB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9jb3JlJztcbmltcG9ydCB7IFNjaGVtYXRpY3NFeGNlcHRpb24gfSBmcm9tICdAYW5ndWxhci1kZXZraXQvc2NoZW1hdGljcyc7XG5pbXBvcnQgeyBUcmVlIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L3NjaGVtYXRpY3Mvc3JjL3RyZWUvaW50ZXJmYWNlJztcbmltcG9ydCB7IGdldFdvcmtzcGFjZSB9IGZyb20gJ0BzY2hlbWF0aWNzL2FuZ3VsYXIvdXRpbGl0eS93b3Jrc3BhY2UnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9qZWN0KFxuICBob3N0OiBUcmVlLFxuICBwcm9qZWN0TmFtZTogc3RyaW5nLFxuKTogUHJvbWlzZTx3b3Jrc3BhY2VzLlByb2plY3REZWZpbml0aW9uPiB7XG4gIGNvbnN0IHdvcmtzcGFjZSA9IGF3YWl0IGdldFdvcmtzcGFjZShob3N0KTtcbiAgY29uc3QgcHJvamVjdCA9IHdvcmtzcGFjZS5wcm9qZWN0cy5nZXQocHJvamVjdE5hbWUpO1xuXG4gIGlmICghcHJvamVjdCB8fCBwcm9qZWN0LmV4dGVuc2lvbnMucHJvamVjdFR5cGUgIT09ICdhcHBsaWNhdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgU2NoZW1hdGljc0V4Y2VwdGlvbihgVW5pdmVyc2FsIHJlcXVpcmVzIGEgcHJvamVjdCB0eXBlIG9mICdhcHBsaWNhdGlvbicuYCk7XG4gIH1cblxuICByZXR1cm4gcHJvamVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwVHNFeHRlbnNpb24oZmlsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGZpbGUucmVwbGFjZSgvXFwudHMkLywgJycpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0T3V0cHV0UGF0aChcbiAgaG9zdDogVHJlZSxcbiAgcHJvamVjdE5hbWU6IHN0cmluZyxcbiAgdGFyZ2V0OiAnc2VydmVyJyB8ICdidWlsZCcsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICAvLyBHZW5lcmF0ZSBuZXcgb3V0cHV0IHBhdGhzXG4gIGNvbnN0IHByb2plY3QgPSBhd2FpdCBnZXRQcm9qZWN0KGhvc3QsIHByb2plY3ROYW1lKTtcbiAgY29uc3Qgc2VydmVyVGFyZ2V0ID0gcHJvamVjdC50YXJnZXRzLmdldCh0YXJnZXQpO1xuICBpZiAoIXNlcnZlclRhcmdldCB8fCAhc2VydmVyVGFyZ2V0Lm9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgU2NoZW1hdGljc0V4Y2VwdGlvblxuICAgICAgKGBDYW5ub3QgZmluZCAnb3B0aW9ucycgZm9yICR7cHJvamVjdE5hbWV9ICR7dGFyZ2V0fSB0YXJnZXQuYCk7XG4gIH1cblxuICBjb25zdCB7IG91dHB1dFBhdGggfSA9IHNlcnZlclRhcmdldC5vcHRpb25zO1xuICBpZiAodHlwZW9mIG91dHB1dFBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFNjaGVtYXRpY3NFeGNlcHRpb25cbiAgICAgIChgb3V0cHV0UGF0aCBmb3IgJHtwcm9qZWN0TmFtZX0gJHt0YXJnZXR9IHRhcmdldCBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0UGF0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbXBvcnQoc291cmNlRmlsZTogdHMuU291cmNlRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbE5hbWU6IHN0cmluZyk6IHRzLk5hbWVkSW1wb3J0cyB8IG51bGwge1xuICAvLyBPbmx5IGxvb2sgdGhyb3VnaCB0aGUgdG9wLWxldmVsIGltcG9ydHMuXG4gIGZvciAoY29uc3Qgbm9kZSBvZiBzb3VyY2VGaWxlLnN0YXRlbWVudHMpIHtcbiAgICBpZiAoIXRzLmlzSW1wb3J0RGVjbGFyYXRpb24obm9kZSkgfHwgIXRzLmlzU3RyaW5nTGl0ZXJhbChub2RlLm1vZHVsZVNwZWNpZmllcikgfHxcbiAgICAgIG5vZGUubW9kdWxlU3BlY2lmaWVyLnRleHQgIT09IG1vZHVsZU5hbWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWVkQmluZGluZ3MgPSBub2RlLmltcG9ydENsYXVzZSAmJiBub2RlLmltcG9ydENsYXVzZS5uYW1lZEJpbmRpbmdzO1xuXG4gICAgaWYgKCFuYW1lZEJpbmRpbmdzIHx8ICF0cy5pc05hbWVkSW1wb3J0cyhuYW1lZEJpbmRpbmdzKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVkQmluZGluZ3MuZWxlbWVudHMuc29tZShlbGVtZW50ID0+IGVsZW1lbnQubmFtZS50ZXh0ID09PSBzeW1ib2xOYW1lKSkge1xuICAgICAgcmV0dXJuIG5hbWVkQmluZGluZ3M7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIEltcG9ydCA9IHtcbiAgbmFtZTogc3RyaW5nLFxuICBpbXBvcnRNb2R1bGU6IHN0cmluZyxcbiAgbm9kZTogdHMuSW1wb3J0RGVjbGFyYXRpb25cbn07XG5cbi8qKiBHZXRzIGltcG9ydCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3BlY2lmaWVkIGlkZW50aWZpZXIgYnkgdXNpbmcgdGhlIFR5cGUgY2hlY2tlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbXBvcnRPZklkZW50aWZpZXIodHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiB0cy5JZGVudGlmaWVyKTogSW1wb3J0IHwgbnVsbCB7XG4gIGNvbnN0IHN5bWJvbCA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZSk7XG5cbiAgaWYgKCFzeW1ib2wgfHwgIXN5bWJvbC5kZWNsYXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBkZWNsID0gc3ltYm9sLmRlY2xhcmF0aW9uc1swXTtcblxuICBpZiAoIXRzLmlzSW1wb3J0U3BlY2lmaWVyKGRlY2wpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBpbXBvcnREZWNsID0gZGVjbC5wYXJlbnQucGFyZW50LnBhcmVudDtcblxuICBpZiAoIXRzLmlzU3RyaW5nTGl0ZXJhbChpbXBvcnREZWNsLm1vZHVsZVNwZWNpZmllcikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gSGFuZGxlcyBhbGlhc2VkIGltcG9ydHM6IGUuZy4gXCJpbXBvcnQge0NvbXBvbmVudCBhcyBteUNvbXB9IGZyb20gLi4uXCI7XG4gICAgbmFtZTogZGVjbC5wcm9wZXJ0eU5hbWUgPyBkZWNsLnByb3BlcnR5TmFtZS50ZXh0IDogZGVjbC5uYW1lLnRleHQsXG4gICAgaW1wb3J0TW9kdWxlOiBpbXBvcnREZWNsLm1vZHVsZVNwZWNpZmllci50ZXh0LFxuICAgIG5vZGU6IGltcG9ydERlY2xcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEluaXRpYWxOYXZpZ2F0aW9uKG5vZGU6IHRzLkNhbGxFeHByZXNzaW9uKTogdHMuQ2FsbEV4cHJlc3Npb24ge1xuICBjb25zdCBleGlzdGluZ09wdGlvbnMgPSBub2RlLmFyZ3VtZW50c1sxXSBhcyB0cy5PYmplY3RMaXRlcmFsRXhwcmVzc2lvbiB8IHVuZGVmaW5lZDtcblxuICAvLyBJZiB0aGUgdXNlciBoYXMgZXhwbGljaXRseSBzZXQgaW5pdGlhbE5hdmlnYXRpb24sIHdlIHJlc3BlY3QgdGhhdFxuICBpZiAoZXhpc3RpbmdPcHRpb25zICYmIGV4aXN0aW5nT3B0aW9ucy5wcm9wZXJ0aWVzLnNvbWUoZXhwID0+XG4gICAgdHMuaXNQcm9wZXJ0eUFzc2lnbm1lbnQoZXhwKSAmJiB0cy5pc0lkZW50aWZpZXIoZXhwLm5hbWUpICYmXG4gICAgZXhwLm5hbWUudGV4dCA9PT0gJ2luaXRpYWxOYXZpZ2F0aW9uJykpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGNvbnN0IGVuYWJsZWRMaXRlcmFsID0gdHMuY3JlYXRlU3RyaW5nTGl0ZXJhbCgnZW5hYmxlZCcpO1xuICAvLyBUeXBlU2NyaXB0IHdpbGwgZW1pdCB0aGUgTm9kZSB3aXRoIGRvdWJsZSBxdW90ZXMuXG4gIC8vIEluIHNjaGVtYXRpY3Mgd2UgdXN1YWxseSB3cml0ZSBjb2RlIHdpdGggYSBzaW5nbGUgcXVvdGVzXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55XG4gIChlbmFibGVkTGl0ZXJhbCBhcyBhbnkpLnNpbmdsZVF1b3RlID0gdHJ1ZTtcblxuICBjb25zdCBpbml0aWFsTmF2aWdhdGlvblByb3BlcnR5XG4gICAgPSB0cy5jcmVhdGVQcm9wZXJ0eUFzc2lnbm1lbnQoJ2luaXRpYWxOYXZpZ2F0aW9uJywgZW5hYmxlZExpdGVyYWwpO1xuICBjb25zdCByb3V0ZXJPcHRpb25zID0gZXhpc3RpbmdPcHRpb25zXG4gICAgPyB0cy51cGRhdGVPYmplY3RMaXRlcmFsKGV4aXN0aW5nT3B0aW9ucywgdHMuY3JlYXRlTm9kZUFycmF5KFtcbiAgICAgIC4uLmV4aXN0aW5nT3B0aW9ucy5wcm9wZXJ0aWVzLFxuICAgICAgaW5pdGlhbE5hdmlnYXRpb25Qcm9wZXJ0eVxuICAgIF0pKVxuICAgIDogdHMuY3JlYXRlT2JqZWN0TGl0ZXJhbChbaW5pdGlhbE5hdmlnYXRpb25Qcm9wZXJ0eV0sIHRydWUpO1xuICBjb25zdCBhcmdzID0gW25vZGUuYXJndW1lbnRzWzBdLCByb3V0ZXJPcHRpb25zXTtcblxuICByZXR1cm4gdHMuY3JlYXRlQ2FsbChub2RlLmV4cHJlc3Npb24sIG5vZGUudHlwZUFyZ3VtZW50cywgYXJncyk7XG59XG4iXX0=
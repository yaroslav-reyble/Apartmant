/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/common/schematics/migrations/update-9/index", ["require", "exports", "@angular-devkit/core", "@angular-devkit/schematics", "@angular-devkit/schematics/tasks", "@schematics/angular/utility/ast-utils", "@schematics/angular/utility/dependencies", "@schematics/angular/utility/workspace", "@schematics/angular/utility/workspace-models", "typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const core_1 = require("@angular-devkit/core");
    const schematics_1 = require("@angular-devkit/schematics");
    const tasks_1 = require("@angular-devkit/schematics/tasks");
    const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
    const dependencies_1 = require("@schematics/angular/utility/dependencies");
    const workspace_1 = require("@schematics/angular/utility/workspace");
    const workspace_models_1 = require("@schematics/angular/utility/workspace-models");
    const ts = require("typescript");
    function version9UpdateRule(collectionPath) {
        return (host) => __awaiter(this, void 0, void 0, function* () {
            return schematics_1.chain([
                backupPackageScriptsRule(),
                updateProjectsStructureRule(collectionPath),
                (tree, context) => {
                    const packageChanges = tree.actions.some(a => a.path.endsWith('/package.json'));
                    if (context && packageChanges) {
                        context.addTask(new tasks_1.NodePackageInstallTask());
                    }
                },
            ]);
        });
    }
    exports.version9UpdateRule = version9UpdateRule;
    function backupPackageScriptsRule() {
        return tree => {
            // Remove old scripts in 'package.json'
            const pkgPath = '/package.json';
            const buffer = tree.read(pkgPath);
            if (!buffer) {
                throw new schematics_1.SchematicsException('Could not find package.json');
            }
            const pkg = JSON.parse(buffer.toString());
            const scripts = pkg.scripts;
            if (!scripts) {
                return;
            }
            // Backup script targets
            [
                'compile:server',
                'build:ssr',
                'serve:ssr',
                'build:client-and-server-bundles',
            ].forEach(key => {
                const keyBackup = `${key}_bak`;
                const scriptValue = scripts[key];
                // Check if script target exists and it has not been already backed up
                if (scriptValue && !scripts[keyBackup]) {
                    scripts[keyBackup] = scriptValue;
                    scripts[key] = undefined;
                }
            });
            tree.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
        };
    }
    function updateProjectsStructureRule(collectionPath) {
        return (tree) => __awaiter(this, void 0, void 0, function* () {
            const workspace = yield workspace_1.getWorkspace(tree);
            const installRules = [];
            for (const [projectName, projectDefinition] of workspace.projects) {
                const serverTarget = projectDefinition.targets.get('server');
                if (!serverTarget || serverTarget.builder !== workspace_models_1.Builders.Server) {
                    // Only process those targets which have a known builder for the CLI
                    continue;
                }
                const root = core_1.normalize(projectDefinition.root);
                // Backup old files
                [
                    'server.ts',
                    'webpack.server.config.js',
                ]
                    .map(f => core_1.join(root, f))
                    .filter(f => tree.exists(f))
                    .forEach(f => tree.rename(f, `${f}.bak`));
                const installOptions = {
                    clientProject: projectName,
                    // Skip install, so we only do one for the entire workspace at the end.
                    skipInstall: true,
                };
                // Run the install schematic again so that we re-create the entire stucture.
                installRules.push(removeModuleMapNgfactoryLoaderRule(core_1.normalize(projectDefinition.sourceRoot)), collectionPath
                    ? schematics_1.externalSchematic(collectionPath, 'ng-add', installOptions)
                    : schematics_1.noop());
            }
            return schematics_1.chain(installRules);
        });
    }
    function removeModuleMapNgfactoryLoaderRule(sourceRoot) {
        return tree => {
            const moduleMapLoaderPackageName = '@nguniversal/module-map-ngfactory-loader';
            // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset which
            // which breaks the CLI UpdateRecorder.
            // See: https://github.com/angular/angular/pull/30719
            const createSourceFile = (path) => ts.createSourceFile(path, tree.read(path).toString().replace(/^\uFEFF/, ''), ts.ScriptTarget.Latest, true);
            // Update main.server file
            const mainServerPath = core_1.join(sourceRoot, 'main.server.ts');
            if (tree.exists(mainServerPath)) {
                const recorder = tree.beginUpdate(mainServerPath);
                // Remove exports of '@nguniversal/module-map-ngfactory-loader'
                createSourceFile(mainServerPath)
                    .statements
                    .filter(s => (ts.isExportDeclaration(s) &&
                    s.moduleSpecifier &&
                    ts.isStringLiteral(s.moduleSpecifier) &&
                    s.moduleSpecifier.text === moduleMapLoaderPackageName))
                    .forEach(node => {
                    const index = node.getFullStart();
                    const length = node.getFullWidth();
                    recorder.remove(index, length);
                });
                tree.commitUpdate(recorder);
            }
            // Update app.server.module file
            const appServerModule = core_1.join(sourceRoot, 'app/app.server.module.ts');
            if (tree.exists(appServerModule)) {
                const recorder = tree.beginUpdate(appServerModule);
                const appServerSourceFile = createSourceFile(appServerModule);
                // Remove imports of '@nguniversal/module-map-ngfactory-loader'
                appServerSourceFile
                    .statements
                    .filter(s => (ts.isImportDeclaration(s) &&
                    s.moduleSpecifier &&
                    ts.isStringLiteral(s.moduleSpecifier) &&
                    s.moduleSpecifier.text === moduleMapLoaderPackageName))
                    .forEach(node => {
                    const index = node.getFullStart();
                    const length = node.getFullWidth();
                    recorder.remove(index, length);
                });
                // Create a TS printer to get the text
                const printer = ts.createPrinter();
                // Remove 'ModuleMapLoaderModule' from 'NgModule' imports
                ast_utils_1.getDecoratorMetadata(appServerSourceFile, 'NgModule', '@angular/core')
                    .forEach((metadata) => {
                    const matchingProperties = ast_utils_1.getMetadataField(metadata, 'imports');
                    if (!matchingProperties) {
                        return;
                    }
                    const assignment = matchingProperties[0];
                    if (!ts.isArrayLiteralExpression(assignment.initializer)) {
                        return;
                    }
                    const arrayLiteral = assignment.initializer;
                    const newImports = arrayLiteral.elements
                        .filter(n => !(ts.isIdentifier(n) && n.text === 'ModuleMapLoaderModule'));
                    if (arrayLiteral.elements.length !== newImports.length) {
                        const newImportsText = printer.printNode(ts.EmitHint.Unspecified, ts.updateArrayLiteral(arrayLiteral, newImports), appServerSourceFile);
                        const index = arrayLiteral.getStart();
                        const length = arrayLiteral.getWidth();
                        recorder
                            .remove(index, length)
                            .insertLeft(index, newImportsText);
                    }
                });
                tree.commitUpdate(recorder);
            }
            // Remove package dependency
            dependencies_1.removePackageJsonDependency(tree, moduleMapLoaderPackageName);
        };
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2NvbW1vbi9zY2hlbWF0aWNzL21pZ3JhdGlvbnMvdXBkYXRlLTkvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFSCwrQ0FBNkQ7SUFDN0QsMkRBTW9DO0lBQ3BDLDREQUEwRTtJQUUxRSxxRUFBK0Y7SUFDL0YsMkVBQXVGO0lBQ3ZGLHFFQUFxRTtJQUNyRSxtRkFBd0U7SUFDeEUsaUNBQWlDO0lBRWpDLFNBQWdCLGtCQUFrQixDQUFDLGNBQXNCO1FBQ3ZELE9BQU8sQ0FBTSxJQUFJLEVBQUMsRUFBRTtZQUNsQixPQUFPLGtCQUFLLENBQUM7Z0JBQ1gsd0JBQXdCLEVBQUU7Z0JBQzFCLDJCQUEyQixDQUFDLGNBQWMsQ0FBQztnQkFDM0MsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLEVBQUU7b0JBQ2hCLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztvQkFDaEYsSUFBSSxPQUFPLElBQUksY0FBYyxFQUFFO3dCQUM3QixPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksOEJBQXNCLEVBQUUsQ0FBQyxDQUFDO3FCQUMvQztnQkFDSCxDQUFDO2FBQ0YsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFBLENBQUM7SUFDSixDQUFDO0lBYkQsZ0RBYUM7SUFFRCxTQUFTLHdCQUF3QjtRQUMvQixPQUFPLElBQUksQ0FBQyxFQUFFO1lBQ1osdUNBQXVDO1lBQ3ZDLE1BQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQztZQUNoQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ2xDLElB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Q0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDN0I7WUFFRCw0QkFBNEI7WUFDNUIsMENBQTJCLENBQUMsSUFBSSxFQUFFLDBCQUEwQixDQUFDLENBQUM7UUFDaEUsQ0FBQyxDQUFDO0lBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgeyBQYXRoLCBqb2luLCBub3JtYWxpemUgfSBmcm9tICdAYW5ndWxhci1kZXZraXQvY29yZSc7XG5pbXBvcnQge1xuICBSdWxlLFxuICBTY2hlbWF0aWNzRXhjZXB0aW9uLFxuICBjaGFpbixcbiAgZXh0ZXJuYWxTY2hlbWF0aWMsXG4gIG5vb3AsXG59IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9zY2hlbWF0aWNzJztcbmltcG9ydCB7IE5vZGVQYWNrYWdlSW5zdGFsbFRhc2sgfSBmcm9tICdAYW5ndWxhci1kZXZraXQvc2NoZW1hdGljcy90YXNrcyc7XG5pbXBvcnQgeyBTY2hlbWEgYXMgVW5pdmVyc2FsT3B0aW9ucyB9IGZyb20gJ0BzY2hlbWF0aWNzL2FuZ3VsYXIvdW5pdmVyc2FsL3NjaGVtYSc7XG5pbXBvcnQgeyBnZXREZWNvcmF0b3JNZXRhZGF0YSwgZ2V0TWV0YWRhdGFGaWVsZCB9IGZyb20gJ0BzY2hlbWF0aWNzL2FuZ3VsYXIvdXRpbGl0eS9hc3QtdXRpbHMnO1xuaW1wb3J0IHsgcmVtb3ZlUGFja2FnZUpzb25EZXBlbmRlbmN5IH0gZnJvbSAnQHNjaGVtYXRpY3MvYW5ndWxhci91dGlsaXR5L2RlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyBnZXRXb3Jrc3BhY2UgfSBmcm9tICdAc2NoZW1hdGljcy9hbmd1bGFyL3V0aWxpdHkvd29ya3NwYWNlJztcbmltcG9ydCB7IEJ1aWxkZXJzIH0gZnJvbSAnQHNjaGVtYXRpY3MvYW5ndWxhci91dGlsaXR5L3dvcmtzcGFjZS1tb2RlbHMnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJzaW9uOVVwZGF0ZVJ1bGUoY29sbGVjdGlvblBhdGg6IHN0cmluZyk6IFJ1bGUge1xuICByZXR1cm4gYXN5bmMgaG9zdCA9PiB7XG4gICAgcmV0dXJuIGNoYWluKFtcbiAgICAgIGJhY2t1cFBhY2thZ2VTY3JpcHRzUnVsZSgpLFxuICAgICAgdXBkYXRlUHJvamVjdHNTdHJ1Y3R1cmVSdWxlKGNvbGxlY3Rpb25QYXRoKSxcbiAgICAgICh0cmVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VDaGFuZ2VzID0gdHJlZS5hY3Rpb25zLnNvbWUoYSA9PiBhLnBhdGguZW5kc1dpdGgoJy9wYWNrYWdlLmpzb24nKSk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHBhY2thZ2VDaGFuZ2VzKSB7XG4gICAgICAgICAgY29udGV4dC5hZGRUYXNrKG5ldyBOb2RlUGFja2FnZUluc3RhbGxUYXNrKCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIF0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBiYWNrdXBQYWNrYWdlU2NyaXB0c1J1bGUoKTogUnVsZSB7XG4gIHJldHVybiB0cmVlID0+IHtcbiAgICAvLyBSZW1vdmUgb2xkIHNjcmlwdHMgaW4gJ3BhY2thZ2UuanNvbidcbiAgICBjb25zdCBwa2dQYXRoID0gJy9wYWNrYWdlLmpzb24nO1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRyZWUucmVhZChwa2dQYXRoKTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IFNjaGVtYXRpY3NFeGNlcHRpb24oJ0NvdWxkIG5vdCBmaW5kIHBhY2thZ2UuanNvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHBrZyA9IEpTT04ucGFyc2UoYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IHNjcmlwdHMgPSBwa2cuc2NyaXB0cztcbiAgICBpZiAoIXNjcmlwdHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCYWNrdXAgc2NyaXB0IHRhcmdldHNcbiAgICBbXG4gICAgICAnY29tcGlsZTpzZXJ2ZXInLFxuICAgICAgJ2J1aWxkOnNzcicsXG4gICAgICAnc2VydmU6c3NyJyxcbiAgICAgICdidWlsZDpjbGllbnQtYW5kLXNlcnZlci1idW5kbGVzJyxcbiAgICBdLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGtleUJhY2t1cCA9IGAke2tleX1fYmFrYDtcbiAgICAgIGNvbnN0IHNjcmlwdFZhbHVlID0gc2NyaXB0c1trZXldO1xuICAgICAgLy8gQ2hlY2sgaWYgc2NyaXB0IHRhcmdldCBleGlzdHMgYW5kIGl0IGhhcyBub3QgYmVlbiBhbHJlYWR5IGJhY2tlZCB1cFxuICAgICAgaWYgKHNjcmlwdFZhbHVlICYmICFzY3JpcHRzW2tleUJhY2t1cF0pIHtcbiAgICAgICAgc2NyaXB0c1trZXlCYWNrdXBdID0gc2NyaXB0VmFsdWU7XG4gICAgICAgIHNjcmlwdHNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyZWUub3ZlcndyaXRlKHBrZ1BhdGgsIEpTT04uc3RyaW5naWZ5KHBrZywgbnVsbCwgMikpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQcm9qZWN0c1N0cnVjdHVyZVJ1bGUoY29sbGVjdGlvblBhdGg6IHN0cmluZyk6IFJ1bGUge1xuICByZXR1cm4gYXN5bmMgdHJlZSA9PiB7XG4gICAgY29uc3Qgd29ya3NwYWNlID0gYXdhaXQgZ2V0V29ya3NwYWNlKHRyZWUpO1xuICAgIGNvbnN0IGluc3RhbGxSdWxlczogUnVsZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtwcm9qZWN0TmFtZSwgcHJvamVjdERlZmluaXRpb25dIG9mIHdvcmtzcGFjZS5wcm9qZWN0cykge1xuICAgICAgY29uc3Qgc2VydmVyVGFyZ2V0ID0gcHJvamVjdERlZmluaXRpb24udGFyZ2V0cy5nZXQoJ3NlcnZlcicpO1xuICAgICAgaWYgKCFzZXJ2ZXJUYXJnZXQgfHwgc2VydmVyVGFyZ2V0LmJ1aWxkZXIgIT09IEJ1aWxkZXJzLlNlcnZlcikge1xuICAgICAgICAvLyBPbmx5IHByb2Nlc3MgdGhvc2UgdGFyZ2V0cyB3aGljaCBoYXZlIGEga25vd24gYnVpbGRlciBmb3IgdGhlIENMSVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm9vdCA9IG5vcm1hbGl6ZShwcm9qZWN0RGVmaW5pdGlvbi5yb290KTtcblxuICAgICAgLy8gQmFja3VwIG9sZCBmaWxlc1xuICAgICAgW1xuICAgICAgICAnc2VydmVyLnRzJyxcbiAgICAgICAgJ3dlYnBhY2suc2VydmVyLmNvbmZpZy5qcycsXG4gICAgICBdXG4gICAgICAgIC5tYXAoZiA9PiBqb2luKHJvb3QsIGYpKVxuICAgICAgICAuZmlsdGVyKGYgPT4gdHJlZS5leGlzdHMoZikpXG4gICAgICAgIC5mb3JFYWNoKGYgPT4gdHJlZS5yZW5hbWUoZiwgYCR7Zn0uYmFrYCkpO1xuXG4gICAgICBjb25zdCBpbnN0YWxsT3B0aW9uczogVW5pdmVyc2FsT3B0aW9ucyA9IHtcbiAgICAgICAgY2xpZW50UHJvamVjdDogcHJvamVjdE5hbWUsXG4gICAgICAgIC8vIFNraXAgaW5zdGFsbCwgc28gd2Ugb25seSBkbyBvbmUgZm9yIHRoZSBlbnRpcmUgd29ya3NwYWNlIGF0IHRoZSBlbmQuXG4gICAgICAgIHNraXBJbnN0YWxsOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgLy8gUnVuIHRoZSBpbnN0YWxsIHNjaGVtYXRpYyBhZ2FpbiBzbyB0aGF0IHdlIHJlLWNyZWF0ZSB0aGUgZW50aXJlIHN0dWN0dXJlLlxuICAgICAgaW5zdGFsbFJ1bGVzLnB1c2goXG4gICAgICAgIHJlbW92ZU1vZHVsZU1hcE5nZmFjdG9yeUxvYWRlclJ1bGUobm9ybWFsaXplKHByb2plY3REZWZpbml0aW9uLnNvdXJjZVJvb3QpKSxcbiAgICAgICAgY29sbGVjdGlvblBhdGhcbiAgICAgICAgICA/IGV4dGVybmFsU2NoZW1hdGljKGNvbGxlY3Rpb25QYXRoLCAnbmctYWRkJywgaW5zdGFsbE9wdGlvbnMpXG4gICAgICAgICAgOiBub29wKCksXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFpbihpbnN0YWxsUnVsZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZW1vdmVNb2R1bGVNYXBOZ2ZhY3RvcnlMb2FkZXJSdWxlKHNvdXJjZVJvb3Q6IFBhdGgpOiBSdWxlIHtcbiAgcmV0dXJuIHRyZWUgPT4ge1xuICAgIGNvbnN0IG1vZHVsZU1hcExvYWRlclBhY2thZ2VOYW1lID0gJ0BuZ3VuaXZlcnNhbC9tb2R1bGUtbWFwLW5nZmFjdG9yeS1sb2FkZXInO1xuXG4gICAgLy8gU3RyaXAgQk9NIGFzIG90aGVyd2lzZSBUU0MgbWV0aG9kcyAoRXg6IGdldFdpZHRoKSB3aWxsIHJldHVybiBhbiBvZmZzZXQgd2hpY2hcbiAgICAvLyB3aGljaCBicmVha3MgdGhlIENMSSBVcGRhdGVSZWNvcmRlci5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvcHVsbC8zMDcxOVxuICAgIGNvbnN0IGNyZWF0ZVNvdXJjZUZpbGUgPSAocGF0aDogc3RyaW5nKSA9PiB0cy5jcmVhdGVTb3VyY2VGaWxlKFxuICAgICAgcGF0aCxcbiAgICAgIHRyZWUucmVhZChwYXRoKS50b1N0cmluZygpLnJlcGxhY2UoL15cXHVGRUZGLywgJycpLFxuICAgICAgdHMuU2NyaXB0VGFyZ2V0LkxhdGVzdCxcbiAgICAgIHRydWUsXG4gICAgKTtcblxuICAgIC8vIFVwZGF0ZSBtYWluLnNlcnZlciBmaWxlXG4gICAgY29uc3QgbWFpblNlcnZlclBhdGggPSBqb2luKHNvdXJjZVJvb3QsICdtYWluLnNlcnZlci50cycpO1xuICAgIGlmICh0cmVlLmV4aXN0cyhtYWluU2VydmVyUGF0aCkpIHtcbiAgICAgIGNvbnN0IHJlY29yZGVyID0gdHJlZS5iZWdpblVwZGF0ZShtYWluU2VydmVyUGF0aCk7XG5cbiAgICAgIC8vIFJlbW92ZSBleHBvcnRzIG9mICdAbmd1bml2ZXJzYWwvbW9kdWxlLW1hcC1uZ2ZhY3RvcnktbG9hZGVyJ1xuICAgICAgY3JlYXRlU291cmNlRmlsZShtYWluU2VydmVyUGF0aClcbiAgICAgICAgLnN0YXRlbWVudHNcbiAgICAgICAgLmZpbHRlcihzID0+IChcbiAgICAgICAgICB0cy5pc0V4cG9ydERlY2xhcmF0aW9uKHMpICYmXG4gICAgICAgICAgcy5tb2R1bGVTcGVjaWZpZXIgJiZcbiAgICAgICAgICB0cy5pc1N0cmluZ0xpdGVyYWwocy5tb2R1bGVTcGVjaWZpZXIpICYmXG4gICAgICAgICAgcy5tb2R1bGVTcGVjaWZpZXIudGV4dCA9PT0gbW9kdWxlTWFwTG9hZGVyUGFja2FnZU5hbWVcbiAgICAgICAgKSlcbiAgICAgICAgLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBub2RlLmdldEZ1bGxTdGFydCgpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG5vZGUuZ2V0RnVsbFdpZHRoKCk7XG4gICAgICAgICAgcmVjb3JkZXIucmVtb3ZlKGluZGV4LCBsZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICAgIHRyZWUuY29tbWl0VXBkYXRlKHJlY29yZGVyKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgYXBwLnNlcnZlci5tb2R1bGUgZmlsZVxuICAgIGNvbnN0IGFwcFNlcnZlck1vZHVsZSA9IGpvaW4oc291cmNlUm9vdCwgJ2FwcC9hcHAuc2VydmVyLm1vZHVsZS50cycpO1xuICAgIGlmICh0cmVlLmV4aXN0cyhhcHBTZXJ2ZXJNb2R1bGUpKSB7XG4gICAgICBjb25zdCByZWNvcmRlciA9IHRyZWUuYmVnaW5VcGRhdGUoYXBwU2VydmVyTW9kdWxlKTtcbiAgICAgIGNvbnN0IGFwcFNlcnZlclNvdXJjZUZpbGUgPSBjcmVhdGVTb3VyY2VGaWxlKGFwcFNlcnZlck1vZHVsZSk7XG5cbiAgICAgIC8vIFJlbW92ZSBpbXBvcnRzIG9mICdAbmd1bml2ZXJzYWwvbW9kdWxlLW1hcC1uZ2ZhY3RvcnktbG9hZGVyJ1xuICAgICAgYXBwU2VydmVyU291cmNlRmlsZVxuICAgICAgICAuc3RhdGVtZW50c1xuICAgICAgICAuZmlsdGVyKHMgPT4gKFxuICAgICAgICAgIHRzLmlzSW1wb3J0RGVjbGFyYXRpb24ocykgJiZcbiAgICAgICAgICBzLm1vZHVsZVNwZWNpZmllciAmJlxuICAgICAgICAgIHRzLmlzU3RyaW5nTGl0ZXJhbChzLm1vZHVsZVNwZWNpZmllcikgJiZcbiAgICAgICAgICBzLm1vZHVsZVNwZWNpZmllci50ZXh0ID09PSBtb2R1bGVNYXBMb2FkZXJQYWNrYWdlTmFtZVxuICAgICAgICApKVxuICAgICAgICAuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IG5vZGUuZ2V0RnVsbFN0YXJ0KCk7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gbm9kZS5nZXRGdWxsV2lkdGgoKTtcbiAgICAgICAgICByZWNvcmRlci5yZW1vdmUoaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgIC8vIENyZWF0ZSBhIFRTIHByaW50ZXIgdG8gZ2V0IHRoZSB0ZXh0XG4gICAgICBjb25zdCBwcmludGVyID0gdHMuY3JlYXRlUHJpbnRlcigpO1xuXG4gICAgICAvLyBSZW1vdmUgJ01vZHVsZU1hcExvYWRlck1vZHVsZScgZnJvbSAnTmdNb2R1bGUnIGltcG9ydHNcbiAgICAgIGdldERlY29yYXRvck1ldGFkYXRhKGFwcFNlcnZlclNvdXJjZUZpbGUsICdOZ01vZHVsZScsICdAYW5ndWxhci9jb3JlJylcbiAgICAgICAgLmZvckVhY2goKG1ldGFkYXRhOiB0cy5PYmplY3RMaXRlcmFsRXhwcmVzc2lvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hdGNoaW5nUHJvcGVydGllcyA9IGdldE1ldGFkYXRhRmllbGQobWV0YWRhdGEsICdpbXBvcnRzJyk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoaW5nUHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBtYXRjaGluZ1Byb3BlcnRpZXNbMF0gYXMgdHMuUHJvcGVydHlBc3NpZ25tZW50O1xuICAgICAgICAgIGlmICghdHMuaXNBcnJheUxpdGVyYWxFeHByZXNzaW9uKGFzc2lnbm1lbnQuaW5pdGlhbGl6ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYXJyYXlMaXRlcmFsID0gYXNzaWdubWVudC5pbml0aWFsaXplcjtcbiAgICAgICAgICBjb25zdCBuZXdJbXBvcnRzID0gYXJyYXlMaXRlcmFsLmVsZW1lbnRzXG4gICAgICAgICAgICAuZmlsdGVyKG4gPT4gISh0cy5pc0lkZW50aWZpZXIobikgJiYgbi50ZXh0ID09PSAnTW9kdWxlTWFwTG9hZGVyTW9kdWxlJykpO1xuXG4gICAgICAgICAgaWYgKGFycmF5TGl0ZXJhbC5lbGVtZW50cy5sZW5ndGggIT09IG5ld0ltcG9ydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdJbXBvcnRzVGV4dCA9IHByaW50ZXIucHJpbnROb2RlKFxuICAgICAgICAgICAgICB0cy5FbWl0SGludC5VbnNwZWNpZmllZCxcbiAgICAgICAgICAgICAgdHMudXBkYXRlQXJyYXlMaXRlcmFsKGFycmF5TGl0ZXJhbCwgbmV3SW1wb3J0cyksXG4gICAgICAgICAgICAgIGFwcFNlcnZlclNvdXJjZUZpbGUsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGFycmF5TGl0ZXJhbC5nZXRTdGFydCgpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlMaXRlcmFsLmdldFdpZHRoKCk7XG5cbiAgICAgICAgICAgIHJlY29yZGVyXG4gICAgICAgICAgICAgIC5yZW1vdmUoaW5kZXgsIGxlbmd0aClcbiAgICAgICAgICAgICAgLmluc2VydExlZnQoaW5kZXgsIG5ld0ltcG9ydHNUZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICB0cmVlLmNvbW1pdFVwZGF0ZShyZWNvcmRlcik7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHBhY2thZ2UgZGVwZW5kZW5jeVxuICAgIHJlbW92ZVBhY2thZ2VKc29uRGVwZW5kZW5jeSh0cmVlLCBtb2R1bGVNYXBMb2FkZXJQYWNrYWdlTmFtZSk7XG4gIH07XG59XG4iXX0=
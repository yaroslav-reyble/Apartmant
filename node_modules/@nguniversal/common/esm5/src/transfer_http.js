import { __decorate, __metadata, __values } from "tslib";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HTTP_INTERCEPTORS, HttpHeaders, HttpResponse } from '@angular/common/http';
import { ApplicationRef, Injectable, NgModule } from '@angular/core';
import { BrowserTransferStateModule, TransferState, makeStateKey } from '@angular/platform-browser';
import { of as observableOf } from 'rxjs';
import { filter, take, tap } from 'rxjs/operators';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/platform-browser';
function getHeadersMap(headers) {
    var e_1, _a;
    var headersMap = {};
    try {
        for (var _b = __values(headers.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            headersMap[key] = headers.getAll(key);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return headersMap;
}
var TransferHttpCacheInterceptor = /** @class */ (function () {
    function TransferHttpCacheInterceptor(appRef, transferState) {
        var _this = this;
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        // tslint:disable-next-line: no-floating-promises
        appRef.isStable
            .pipe(filter(function (isStable) { return isStable; }), take(1)).toPromise()
            .then(function () { _this.isCacheActive = false; });
    }
    TransferHttpCacheInterceptor.prototype.invalidateCacheEntry = function (url) {
        var _this = this;
        Object.keys(this.transferState['store'])
            .forEach(function (key) { return key.includes(url) ? _this.transferState.remove(makeStateKey(key)) : null; });
    };
    TransferHttpCacheInterceptor.prototype.makeCacheKey = function (method, url, params) {
        // make the params encoded same as a url so it's easy to identify
        var encodedParams = params.keys().sort().map(function (k) { return k + "=" + params.get(k); }).join('&');
        var key = (method === 'GET' ? 'G.' : 'H.') + url + '?' + encodedParams;
        return makeStateKey(key);
    };
    TransferHttpCacheInterceptor.prototype.intercept = function (req, next) {
        var _this = this;
        // Stop using the cache if there is a mutating call.
        if (req.method !== 'GET' && req.method !== 'HEAD') {
            this.isCacheActive = false;
            this.invalidateCacheEntry(req.url);
        }
        if (!this.isCacheActive) {
            // Cache is no longer active. Pass the request through.
            return next.handle(req);
        }
        var storeKey = this.makeCacheKey(req.method, req.url, req.params);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            var response = this.transferState.get(storeKey, {});
            return observableOf(new HttpResponse({
                body: response.body,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        else {
            // Request not found in cache. Make the request and cache it.
            var httpEvent = next.handle(req);
            return httpEvent
                .pipe(tap(function (event) {
                if (event instanceof HttpResponse) {
                    _this.transferState.set(storeKey, {
                        body: event.body,
                        headers: getHeadersMap(event.headers),
                        status: event.status,
                        statusText: event.statusText,
                        url: event.url || '',
                    });
                }
            }));
        }
    };
    TransferHttpCacheInterceptor = __decorate([ __metadata("design:paramtypes", [ApplicationRef, TransferState])
    ], TransferHttpCacheInterceptor);
TransferHttpCacheInterceptor.ɵfac = function TransferHttpCacheInterceptor_Factory(t) { return new (t || TransferHttpCacheInterceptor)(ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc1.TransferState)); };
TransferHttpCacheInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TransferHttpCacheInterceptor, factory: function (t) { return TransferHttpCacheInterceptor.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TransferHttpCacheInterceptor, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ApplicationRef }, { type: ɵngcc1.TransferState }]; }, null); })();
    return TransferHttpCacheInterceptor;
}());
export { TransferHttpCacheInterceptor };
/**
 * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP
 * calls from the server to the client application.
 */
var TransferHttpCacheModule = /** @class */ (function () {
    function TransferHttpCacheModule() {
    }
TransferHttpCacheModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TransferHttpCacheModule });
TransferHttpCacheModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TransferHttpCacheModule_Factory(t) { return new (t || TransferHttpCacheModule)(); }, providers: [
        TransferHttpCacheInterceptor,
        { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
    ], imports: [[BrowserTransferStateModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TransferHttpCacheModule, { imports: function () { return [BrowserTransferStateModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TransferHttpCacheModule, [{
        type: NgModule,
        args: [{
                imports: [BrowserTransferStateModule],
                providers: [
                    TransferHttpCacheInterceptor,
                    { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                ]
            }]
    }], function () { return []; }, null); })();
    return TransferHttpCacheModule;
}());
export { TransferHttpCacheModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfaHR0cC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbW9kdWxlcy9jb21tb24vc3JjL3RyYW5zZmVyX2h0dHAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7R0FNRztBQUNILE9BQU8sRUFDTCxpQkFBaUIsRUFHakIsV0FBVyxFQUlYLFlBQVksRUFDYixNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQ0wsMEJBQTBCLEVBRTFCLGFBQWEsRUFDYixZQUFZLEVBQ2IsTUFBTSwyQkFBMkIsQ0FBQztBQUNuQyxPQUFPLEVBQWMsRUFBRSxJQUFJLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBVW5ELFNBQVMsYUFBYSxDQUFDLE9BQW9COztJQUN6QyxJQUFNLFVBQVUsR0FBb0MsRUFBRSxDQUFDOztRQUN2RCxLQUFrQixJQUFBLEtBQUEsU0FBQSxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUEsZ0JBQUEsNEJBQUU7WUFBN0IsSUFBTSxHQUFHLFdBQUE7WUFDWixVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN2Qzs7Ozs7Ozs7O0lBRUQsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQztBQUdEO0lBaUJFLHNDQUFZLE1BQXNCLEVBQVUsYUFBNEI7UUFBeEUsaUJBVUM7UUFWMkMsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFmaEUsa0JBQWEsR0FBRyxJQUFJLENBQUM7UUFnQjNCLDBGQUEwRjtRQUMxRixZQUFZO1FBQ1osaURBQWlEO1FBQ2pELE1BQU0sQ0FBQyxRQUFRO2FBQ1osSUFBSSxDQUNILE1BQU0sQ0FBQyxV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Q0FBQyxVQUFDLEtBQXlCO2dCQUM1QixJQUFJLEtBQUssWUFBWSxZQUFZLEVBQUU7b0JBQ2pDLEtBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRTt3QkFDL0IsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJO3dCQUNoQixPQUFPLEVBQUUsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7d0JBQ3JDLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTTt3QkFDcEIsVUFBVSxFQUFFLEtBQUssQ0FBQyxVQUFVO3dCQUM1QixHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUcsSUFBSSxFQUFFO3FCQUNyQixDQUFDLENBQUM7aUJBQ0o7WUFDSCxDQUFDLENBQUMsQ0FDSCxDQUFDO1NBQ0w7SUFDSCxDQUFDO0lBekVVLDRCQUE0QixlQUFlLFNBRHZELFVBQVUsRUFBRSxyQkFDTCxrQ0FpQmMsY0FBYyxFQUF5QixhQUFhO09BakI3RCw0QkFBNEIsQ0EwRXhDOzs7OzsrR0FDRDtJQURBLG1DQUFDO0NBQUEsQUExRUQsSUEwRUM7U0ExRVksNEJBQTRCO0FBNEV6Qzs7O0dBR0c7QUFRSDtJQUFBO0lBQXNDLENBQUM7SUFBMUIsdUJBQXVCLHdCQVBuQyxRQUFRLENBQUMsY0FDUixPQUFPLEVBQUUsQ0FBQzttQkFBMEIsQ0FBQyxjQUNyQyxTQUFTLEVBQUUsa0JBQ1QsNEJBQTRCLGtCQUM1QixFQUFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUU7T0FBNEIsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDLGVBQ3JGO1VBQ0YsQ0FBQyxRQUNXLHVCQUF1QixDQUFHOzs7Ozs7Ozs7Ozs7Z0RBQ3ZDO0lBRHNDLDhCQUFDO0NBQUEsQUFBdkMsSUFBdUM7U0FBMUIsdUJBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQge1xuICBIVFRQX0lOVEVSQ0VQVE9SUyxcbiAgSHR0cEV2ZW50LFxuICBIdHRwSGFuZGxlcixcbiAgSHR0cEhlYWRlcnMsXG4gIEh0dHBJbnRlcmNlcHRvcixcbiAgSHR0cFBhcmFtcyxcbiAgSHR0cFJlcXVlc3QsXG4gIEh0dHBSZXNwb25zZVxufSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBBcHBsaWNhdGlvblJlZiwgSW5qZWN0YWJsZSwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEJyb3dzZXJUcmFuc2ZlclN0YXRlTW9kdWxlLFxuICBTdGF0ZUtleSxcbiAgVHJhbnNmZXJTdGF0ZSxcbiAgbWFrZVN0YXRlS2V5XG59IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgYXMgb2JzZXJ2YWJsZU9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2UsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zlckh0dHBSZXNwb25zZSB7XG4gIGJvZHk/OiBhbnkgfCBudWxsO1xuICBoZWFkZXJzPzoge1trOiBzdHJpbmddOiBzdHJpbmdbXX07XG4gIHN0YXR1cz86IG51bWJlcjtcbiAgc3RhdHVzVGV4dD86IHN0cmluZztcbiAgdXJsPzogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBnZXRIZWFkZXJzTWFwKGhlYWRlcnM6IEh0dHBIZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdIHwgbnVsbD4gPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgaGVhZGVycy5rZXlzKCkpIHtcbiAgICBoZWFkZXJzTWFwW2tleV0gPSBoZWFkZXJzLmdldEFsbChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnNNYXA7XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUcmFuc2Zlckh0dHBDYWNoZUludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yIHtcblxuICBwcml2YXRlIGlzQ2FjaGVBY3RpdmUgPSB0cnVlO1xuXG4gIHByaXZhdGUgaW52YWxpZGF0ZUNhY2hlRW50cnkodXJsOiBzdHJpbmcpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLnRyYW5zZmVyU3RhdGVbJ3N0b3JlJ10pXG4gICAgICAuZm9yRWFjaChrZXkgPT4ga2V5LmluY2x1ZGVzKHVybCkgPyB0aGlzLnRyYW5zZmVyU3RhdGUucmVtb3ZlKG1ha2VTdGF0ZUtleShrZXkpKSA6IG51bGwpO1xuICB9XG5cbiAgcHJpdmF0ZSBtYWtlQ2FjaGVLZXkobWV0aG9kOiBzdHJpbmcsIHVybDogc3RyaW5nLCBwYXJhbXM6IEh0dHBQYXJhbXMpOiBTdGF0ZUtleTxzdHJpbmc+IHtcbiAgICAvLyBtYWtlIHRoZSBwYXJhbXMgZW5jb2RlZCBzYW1lIGFzIGEgdXJsIHNvIGl0J3MgZWFzeSB0byBpZGVudGlmeVxuICAgIGNvbnN0IGVuY29kZWRQYXJhbXMgPSBwYXJhbXMua2V5cygpLnNvcnQoKS5tYXAoayA9PiBgJHtrfT0ke3BhcmFtcy5nZXQoayl9YCkuam9pbignJicpO1xuICAgIGNvbnN0IGtleSA9IChtZXRob2QgPT09ICdHRVQnID8gJ0cuJyA6ICdILicpICsgdXJsICsgJz8nICsgZW5jb2RlZFBhcmFtcztcblxuICAgIHJldHVybiBtYWtlU3RhdGVLZXk8VHJhbnNmZXJIdHRwUmVzcG9uc2U+KGtleSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhcHBSZWY6IEFwcGxpY2F0aW9uUmVmLCBwcml2YXRlIHRyYW5zZmVyU3RhdGU6IFRyYW5zZmVyU3RhdGUpIHtcbiAgICAvLyBTdG9wIHVzaW5nIHRoZSBjYWNoZSBpZiB0aGUgYXBwbGljYXRpb24gaGFzIHN0YWJpbGl6ZWQsIGluZGljYXRpbmcgaW5pdGlhbCByZW5kZXJpbmcgaXNcbiAgICAvLyBjb21wbGV0ZS5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgYXBwUmVmLmlzU3RhYmxlXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChpc1N0YWJsZTogYm9vbGVhbikgPT4gaXNTdGFibGUpLFxuICAgICAgICB0YWtlKDEpXG4gICAgICApLnRvUHJvbWlzZSgpXG4gICAgICAudGhlbigoKSA9PiB7IHRoaXMuaXNDYWNoZUFjdGl2ZSA9IGZhbHNlOyB9KTtcbiAgfVxuXG4gIGludGVyY2VwdChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuICAgIC8vIFN0b3AgdXNpbmcgdGhlIGNhY2hlIGlmIHRoZXJlIGlzIGEgbXV0YXRpbmcgY2FsbC5cbiAgICBpZiAocmVxLm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLmlzQ2FjaGVBY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUNhY2hlRW50cnkocmVxLnVybCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzQ2FjaGVBY3RpdmUpIHtcbiAgICAgIC8vIENhY2hlIGlzIG5vIGxvbmdlciBhY3RpdmUuIFBhc3MgdGhlIHJlcXVlc3QgdGhyb3VnaC5cbiAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlS2V5ID0gdGhpcy5tYWtlQ2FjaGVLZXkocmVxLm1ldGhvZCwgcmVxLnVybCwgcmVxLnBhcmFtcyk7XG5cbiAgICBpZiAodGhpcy50cmFuc2ZlclN0YXRlLmhhc0tleShzdG9yZUtleSkpIHtcbiAgICAgIC8vIFJlcXVlc3QgZm91bmQgaW4gY2FjaGUuIFJlc3BvbmQgdXNpbmcgaXQuXG4gICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMudHJhbnNmZXJTdGF0ZS5nZXQoc3RvcmVLZXksIHt9IGFzIFRyYW5zZmVySHR0cFJlc3BvbnNlKTtcblxuICAgICAgcmV0dXJuIG9ic2VydmFibGVPZihuZXcgSHR0cFJlc3BvbnNlPGFueT4oe1xuICAgICAgICBib2R5OiByZXNwb25zZS5ib2R5LFxuICAgICAgICBoZWFkZXJzOiBuZXcgSHR0cEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVxdWVzdCBub3QgZm91bmQgaW4gY2FjaGUuIE1ha2UgdGhlIHJlcXVlc3QgYW5kIGNhY2hlIGl0LlxuICAgICAgY29uc3QgaHR0cEV2ZW50ID0gbmV4dC5oYW5kbGUocmVxKTtcblxuICAgICAgcmV0dXJuIGh0dHBFdmVudFxuICAgICAgICAucGlwZShcbiAgICAgICAgICB0YXAoKGV2ZW50OiBIdHRwRXZlbnQ8dW5rbm93bj4pID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSkge1xuICAgICAgICAgICAgICB0aGlzLnRyYW5zZmVyU3RhdGUuc2V0KHN0b3JlS2V5LCB7XG4gICAgICAgICAgICAgICAgYm9keTogZXZlbnQuYm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzTWFwKGV2ZW50LmhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogZXZlbnQuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IGV2ZW50LnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgdXJsOiBldmVudC51cmwgfHwgJycsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gTmdNb2R1bGUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBTZXJ2ZXJUcmFuc2Zlckh0dHBDYWNoZU1vZHVsZWAgdG8gdHJhbnNmZXIgY2FjaGVkIEhUVFBcbiAqIGNhbGxzIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IGFwcGxpY2F0aW9uLlxuICovXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQnJvd3NlclRyYW5zZmVyU3RhdGVNb2R1bGVdLFxuICBwcm92aWRlcnM6IFtcbiAgICBUcmFuc2Zlckh0dHBDYWNoZUludGVyY2VwdG9yLFxuICAgIHtwcm92aWRlOiBIVFRQX0lOVEVSQ0VQVE9SUywgdXNlRXhpc3Rpbmc6IFRyYW5zZmVySHR0cENhY2hlSW50ZXJjZXB0b3IsIG11bHRpOiB0cnVlfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgVHJhbnNmZXJIdHRwQ2FjaGVNb2R1bGUge31cbiJdfQ==
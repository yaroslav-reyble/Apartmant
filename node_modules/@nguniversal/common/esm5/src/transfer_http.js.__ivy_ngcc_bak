import { __decorate, __metadata, __values } from "tslib";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HTTP_INTERCEPTORS, HttpHeaders, HttpResponse } from '@angular/common/http';
import { ApplicationRef, Injectable, NgModule } from '@angular/core';
import { BrowserTransferStateModule, TransferState, makeStateKey } from '@angular/platform-browser';
import { of as observableOf } from 'rxjs';
import { filter, take, tap } from 'rxjs/operators';
function getHeadersMap(headers) {
    var e_1, _a;
    var headersMap = {};
    try {
        for (var _b = __values(headers.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            headersMap[key] = headers.getAll(key);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return headersMap;
}
var TransferHttpCacheInterceptor = /** @class */ (function () {
    function TransferHttpCacheInterceptor(appRef, transferState) {
        var _this = this;
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        // tslint:disable-next-line: no-floating-promises
        appRef.isStable
            .pipe(filter(function (isStable) { return isStable; }), take(1)).toPromise()
            .then(function () { _this.isCacheActive = false; });
    }
    TransferHttpCacheInterceptor.prototype.invalidateCacheEntry = function (url) {
        var _this = this;
        Object.keys(this.transferState['store'])
            .forEach(function (key) { return key.includes(url) ? _this.transferState.remove(makeStateKey(key)) : null; });
    };
    TransferHttpCacheInterceptor.prototype.makeCacheKey = function (method, url, params) {
        // make the params encoded same as a url so it's easy to identify
        var encodedParams = params.keys().sort().map(function (k) { return k + "=" + params.get(k); }).join('&');
        var key = (method === 'GET' ? 'G.' : 'H.') + url + '?' + encodedParams;
        return makeStateKey(key);
    };
    TransferHttpCacheInterceptor.prototype.intercept = function (req, next) {
        var _this = this;
        // Stop using the cache if there is a mutating call.
        if (req.method !== 'GET' && req.method !== 'HEAD') {
            this.isCacheActive = false;
            this.invalidateCacheEntry(req.url);
        }
        if (!this.isCacheActive) {
            // Cache is no longer active. Pass the request through.
            return next.handle(req);
        }
        var storeKey = this.makeCacheKey(req.method, req.url, req.params);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            var response = this.transferState.get(storeKey, {});
            return observableOf(new HttpResponse({
                body: response.body,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        else {
            // Request not found in cache. Make the request and cache it.
            var httpEvent = next.handle(req);
            return httpEvent
                .pipe(tap(function (event) {
                if (event instanceof HttpResponse) {
                    _this.transferState.set(storeKey, {
                        body: event.body,
                        headers: getHeadersMap(event.headers),
                        status: event.status,
                        statusText: event.statusText,
                        url: event.url || '',
                    });
                }
            }));
        }
    };
    TransferHttpCacheInterceptor = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [ApplicationRef, TransferState])
    ], TransferHttpCacheInterceptor);
    return TransferHttpCacheInterceptor;
}());
export { TransferHttpCacheInterceptor };
/**
 * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP
 * calls from the server to the client application.
 */
var TransferHttpCacheModule = /** @class */ (function () {
    function TransferHttpCacheModule() {
    }
    TransferHttpCacheModule = __decorate([
        NgModule({
            imports: [BrowserTransferStateModule],
            providers: [
                TransferHttpCacheInterceptor,
                { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
            ],
        })
    ], TransferHttpCacheModule);
    return TransferHttpCacheModule;
}());
export { TransferHttpCacheModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfaHR0cC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL21vZHVsZXMvY29tbW9uL3NyYy90cmFuc2Zlcl9odHRwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUc7QUFDSCxPQUFPLEVBQ0wsaUJBQWlCLEVBR2pCLFdBQVcsRUFJWCxZQUFZLEVBQ2IsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsY0FBYyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckUsT0FBTyxFQUNMLDBCQUEwQixFQUUxQixhQUFhLEVBQ2IsWUFBWSxFQUNiLE1BQU0sMkJBQTJCLENBQUM7QUFDbkMsT0FBTyxFQUFjLEVBQUUsSUFBSSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFVbkQsU0FBUyxhQUFhLENBQUMsT0FBb0I7O0lBQ3pDLElBQU0sVUFBVSxHQUFvQyxFQUFFLENBQUM7O1FBQ3ZELEtBQWtCLElBQUEsS0FBQSxTQUFBLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQSxnQkFBQSw0QkFBRTtZQUE3QixJQUFNLEdBQUcsV0FBQTtZQUNaLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3ZDOzs7Ozs7Ozs7SUFFRCxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDO0FBR0Q7SUFpQkUsc0NBQVksTUFBc0IsRUFBVSxhQUE0QjtRQUF4RSxpQkFVQztRQVYyQyxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQWZoRSxrQkFBYSxHQUFHLElBQUksQ0FBQztRQWdCM0IsMEZBQTBGO1FBQzFGLFlBQVk7UUFDWixpREFBaUQ7UUFDakQsTUFBTSxDQUFDLFFBQVE7YUFDWixJQUFJ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YixJQUFJLENBQ0gsR0FBRyxDQUFDLFVBQUMsS0FBeUI7Z0JBQzVCLElBQUksS0FBSyxZQUFZLFlBQVksRUFBRTtvQkFDakMsS0FBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFO3dCQUMvQixJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUk7d0JBQ2hCLE9BQU8sRUFBRSxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQzt3QkFDckMsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNO3dCQUNwQixVQUFVLEVBQUUsS0FBSyxDQUFDLFVBQVU7d0JBQzVCLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRyxJQUFJLEVBQUU7cUJBQ3JCLENBQUMsQ0FBQztpQkFDSjtZQUNILENBQUMsQ0FBQyxDQUNILENBQUM7U0FDTDtJQUNILENBQUM7SUF6RVUsNEJBQTRCO1FBRHhDLFVBQVUsRUFBRTt5Q0FrQlMsY0FBYyxFQUF5QixhQUFhO09BakI3RCw0QkFBNEIsQ0EwRXhDO0lBQUQsbUNBQUM7Q0FBQSxBQTFFRCxJQTBFQztTQTFFWSw0QkFBNEI7QUE0RXpDOzs7R0FHRztBQVFIO0lBQUE7SUFBc0MsQ0FBQztJQUExQix1QkFBdUI7UUFQbkMsUUFBUSxDQUFDO1lBQ1IsT0FBTyxFQUFFLENBQUMsMEJBQTBCLENBQUM7WUFDckMsU0FBUyxFQUFFO2dCQUNULDRCQUE0QjtnQkFDNUIsRUFBQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLDRCQUE0QixFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUM7YUFDckY7U0FDRixDQUFDO09BQ1csdUJBQXVCLENBQUc7SUFBRCw4QkFBQztDQUFBLEFBQXZDLElBQXVDO1NBQTFCLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcbiAgSFRUUF9JTlRFUkNFUFRPUlMsXG4gIEh0dHBFdmVudCxcbiAgSHR0cEhhbmRsZXIsXG4gIEh0dHBIZWFkZXJzLFxuICBIdHRwSW50ZXJjZXB0b3IsXG4gIEh0dHBQYXJhbXMsXG4gIEh0dHBSZXF1ZXN0LFxuICBIdHRwUmVzcG9uc2Vcbn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgQXBwbGljYXRpb25SZWYsIEluamVjdGFibGUsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZSxcbiAgU3RhdGVLZXksXG4gIFRyYW5zZmVyU3RhdGUsXG4gIG1ha2VTdGF0ZUtleVxufSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIGFzIG9ic2VydmFibGVPZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJIdHRwUmVzcG9uc2Uge1xuICBib2R5PzogYW55IHwgbnVsbDtcbiAgaGVhZGVycz86IHtbazogc3RyaW5nXTogc3RyaW5nW119O1xuICBzdGF0dXM/OiBudW1iZXI7XG4gIHN0YXR1c1RleHQ/OiBzdHJpbmc7XG4gIHVybD86IHN0cmluZztcbn1cblxuZnVuY3Rpb24gZ2V0SGVhZGVyc01hcChoZWFkZXJzOiBIdHRwSGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXSB8IG51bGw+ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGhlYWRlcnMua2V5cygpKSB7XG4gICAgaGVhZGVyc01hcFtrZXldID0gaGVhZGVycy5nZXRBbGwoa2V5KTtcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzTWFwO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJhbnNmZXJIdHRwQ2FjaGVJbnRlcmNlcHRvciBpbXBsZW1lbnRzIEh0dHBJbnRlcmNlcHRvciB7XG5cbiAgcHJpdmF0ZSBpc0NhY2hlQWN0aXZlID0gdHJ1ZTtcblxuICBwcml2YXRlIGludmFsaWRhdGVDYWNoZUVudHJ5KHVybDogc3RyaW5nKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy50cmFuc2ZlclN0YXRlWydzdG9yZSddKVxuICAgICAgLmZvckVhY2goa2V5ID0+IGtleS5pbmNsdWRlcyh1cmwpID8gdGhpcy50cmFuc2ZlclN0YXRlLnJlbW92ZShtYWtlU3RhdGVLZXkoa2V5KSkgOiBudWxsKTtcbiAgfVxuXG4gIHByaXZhdGUgbWFrZUNhY2hlS2V5KG1ldGhvZDogc3RyaW5nLCB1cmw6IHN0cmluZywgcGFyYW1zOiBIdHRwUGFyYW1zKTogU3RhdGVLZXk8c3RyaW5nPiB7XG4gICAgLy8gbWFrZSB0aGUgcGFyYW1zIGVuY29kZWQgc2FtZSBhcyBhIHVybCBzbyBpdCdzIGVhc3kgdG8gaWRlbnRpZnlcbiAgICBjb25zdCBlbmNvZGVkUGFyYW1zID0gcGFyYW1zLmtleXMoKS5zb3J0KCkubWFwKGsgPT4gYCR7a309JHtwYXJhbXMuZ2V0KGspfWApLmpvaW4oJyYnKTtcbiAgICBjb25zdCBrZXkgPSAobWV0aG9kID09PSAnR0VUJyA/ICdHLicgOiAnSC4nKSArIHVybCArICc/JyArIGVuY29kZWRQYXJhbXM7XG5cbiAgICByZXR1cm4gbWFrZVN0YXRlS2V5PFRyYW5zZmVySHR0cFJlc3BvbnNlPihrZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYXBwUmVmOiBBcHBsaWNhdGlvblJlZiwgcHJpdmF0ZSB0cmFuc2ZlclN0YXRlOiBUcmFuc2ZlclN0YXRlKSB7XG4gICAgLy8gU3RvcCB1c2luZyB0aGUgY2FjaGUgaWYgdGhlIGFwcGxpY2F0aW9uIGhhcyBzdGFiaWxpemVkLCBpbmRpY2F0aW5nIGluaXRpYWwgcmVuZGVyaW5nIGlzXG4gICAgLy8gY29tcGxldGUuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1mbG9hdGluZy1wcm9taXNlc1xuICAgIGFwcFJlZi5pc1N0YWJsZVxuICAgICAgLnBpcGUoXG4gICAgICAgIGZpbHRlcigoaXNTdGFibGU6IGJvb2xlYW4pID0+IGlzU3RhYmxlKSxcbiAgICAgICAgdGFrZSgxKVxuICAgICAgKS50b1Byb21pc2UoKVxuICAgICAgLnRoZW4oKCkgPT4geyB0aGlzLmlzQ2FjaGVBY3RpdmUgPSBmYWxzZTsgfSk7XG4gIH1cblxuICBpbnRlcmNlcHQocmVxOiBIdHRwUmVxdWVzdDxhbnk+LCBuZXh0OiBIdHRwSGFuZGxlcik6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICAvLyBTdG9wIHVzaW5nIHRoZSBjYWNoZSBpZiB0aGVyZSBpcyBhIG11dGF0aW5nIGNhbGwuXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnICYmIHJlcS5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgdGhpcy5pc0NhY2hlQWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLmludmFsaWRhdGVDYWNoZUVudHJ5KHJlcS51cmwpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0NhY2hlQWN0aXZlKSB7XG4gICAgICAvLyBDYWNoZSBpcyBubyBsb25nZXIgYWN0aXZlLiBQYXNzIHRoZSByZXF1ZXN0IHRocm91Z2guXG4gICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZUtleSA9IHRoaXMubWFrZUNhY2hlS2V5KHJlcS5tZXRob2QsIHJlcS51cmwsIHJlcS5wYXJhbXMpO1xuXG4gICAgaWYgKHRoaXMudHJhbnNmZXJTdGF0ZS5oYXNLZXkoc3RvcmVLZXkpKSB7XG4gICAgICAvLyBSZXF1ZXN0IGZvdW5kIGluIGNhY2hlLiBSZXNwb25kIHVzaW5nIGl0LlxuICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnRyYW5zZmVyU3RhdGUuZ2V0KHN0b3JlS2V5LCB7fSBhcyBUcmFuc2Zlckh0dHBSZXNwb25zZSk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZhYmxlT2YobmV3IEh0dHBSZXNwb25zZTxhbnk+KHtcbiAgICAgICAgYm9keTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgaGVhZGVyczogbmV3IEh0dHBIZWFkZXJzKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcXVlc3Qgbm90IGZvdW5kIGluIGNhY2hlLiBNYWtlIHRoZSByZXF1ZXN0IGFuZCBjYWNoZSBpdC5cbiAgICAgIGNvbnN0IGh0dHBFdmVudCA9IG5leHQuaGFuZGxlKHJlcSk7XG5cbiAgICAgIHJldHVybiBodHRwRXZlbnRcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgdGFwKChldmVudDogSHR0cEV2ZW50PHVua25vd24+KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2ZlclN0YXRlLnNldChzdG9yZUtleSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGV2ZW50LmJvZHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVyc01hcChldmVudC5oZWFkZXJzKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGV2ZW50LnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBldmVudC5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIHVybDogZXZlbnQudXJsIHx8ICcnLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIE5nTW9kdWxlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgU2VydmVyVHJhbnNmZXJIdHRwQ2FjaGVNb2R1bGVgIHRvIHRyYW5zZmVyIGNhY2hlZCBIVFRQXG4gKiBjYWxscyBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCBhcHBsaWNhdGlvbi5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0Jyb3dzZXJUcmFuc2ZlclN0YXRlTW9kdWxlXSxcbiAgcHJvdmlkZXJzOiBbXG4gICAgVHJhbnNmZXJIdHRwQ2FjaGVJbnRlcmNlcHRvcixcbiAgICB7cHJvdmlkZTogSFRUUF9JTlRFUkNFUFRPUlMsIHVzZUV4aXN0aW5nOiBUcmFuc2Zlckh0dHBDYWNoZUludGVyY2VwdG9yLCBtdWx0aTogdHJ1ZX0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIFRyYW5zZmVySHR0cENhY2hlTW9kdWxlIHt9XG4iXX0=
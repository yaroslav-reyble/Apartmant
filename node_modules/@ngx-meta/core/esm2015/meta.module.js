import * as ɵngcc0 from '@angular/core';
var MetaModule_1;
import * as tslib_1 from "tslib";
import { NgModule, Optional, SkipSelf } from '@angular/core';
import { MetaGuard } from './meta.guard';
import { MetaLoader, MetaStaticLoader } from './meta.loader';
import { MetaService } from './meta.service';
export const metaFactory = () => new MetaStaticLoader();
let MetaModule = MetaModule_1 = class MetaModule {
    constructor(parentModule) {
        if (parentModule) {
            throw new Error('MetaModule already loaded; import in root module only.');
        }
    }
    static forRoot(configuredProvider = {
        provide: MetaLoader,
        useFactory: metaFactory
    }) {
        return {
            ngModule: MetaModule_1,
            providers: [configuredProvider, MetaGuard, MetaService]
        };
    }
};
MetaModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MetaModule });
MetaModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MetaModule_Factory(t) { return new (t || MetaModule)(ɵngcc0.ɵɵinject(MetaModule, 12)); } });
MetaModule.ctorParameters = () => [
    { type: MetaModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
MetaModule = MetaModule_1 = tslib_1.__decorate([ tslib_1.__param(0, Optional()), tslib_1.__param(0, SkipSelf()),
    tslib_1.__metadata("design:paramtypes", [MetaModule])
], MetaModule);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MetaModule, [{
        type: NgModule
    }], function () { return [{ type: MetaModule, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }]; }, null); })();
export { MetaModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0YS5tb2R1bGUuanMiLCJzb3VyY2VzIjpbIm5nOi9Abmd4LW1ldGEvY29yZS9tZXRhLm1vZHVsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxPQUFPLEVBQXVCLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRWxGLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDekMsT0FBTyxFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM3RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFN0MsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksZ0JBQWdCLEVBQUUsQ0FBQztBQUd4RCxJQUFhLFVBQVUsa0JBQXZCLE1BQWEsVUFBVTtJQWFyQixZQUFvQyxZQUF5QjtRQUMzRCxJQUFJLFlBQVksRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7U0FDM0U7SUFDSCxDQUFDO0lBaEJELE1BQU0sQ0FBQyxPQUFPLENBQ1oscUJBQTBCO1FBQ3hCLE9BQU8sRUFBRSxVQUFVO1FBQ25CLFVBQVUsRUFBRSxXQUFXO0tBQ3hCO1FBRUQsT0FBTztZQUNMLFFBQVEsRUFBRSxZQUFVO1lBQ3BCLFNBQVMsRUFBRSxDQUFDLGtCQUFrQixFQUFFLFNBQVMsRUFBRSxXQUFXLENBQUM7U0FDeEQsQ0FBQztJQUNKLENBQUM7Q0FPRjs7MEpBQUE7O1lBTG9ELFVBQVUsdUJBQWhELFFBQVEsWUFBSSxRQUFROztBQWJ0QixVQUFVLHNDQUVOLEtBSGhCLFFBQVEsRUFBRSxmQUNQLENBYVcsbUJBQUEsUUFBUSxFQUFFLENBQUEsRUFBRSxtQkFBQSxRQUFRLEVBQUUsQ0FBQTs2Q0FBZ0IsVUFBVTtHQWJsRCxVQUFVLENBa0J0Qjs7Ozs7OztrQ0FDRDtTQW5CYSxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGUsIE9wdGlvbmFsLCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBNZXRhR3VhcmQgfSBmcm9tICcuL21ldGEuZ3VhcmQnO1xuaW1wb3J0IHsgTWV0YUxvYWRlciwgTWV0YVN0YXRpY0xvYWRlciB9IGZyb20gJy4vbWV0YS5sb2FkZXInO1xuaW1wb3J0IHsgTWV0YVNlcnZpY2UgfSBmcm9tICcuL21ldGEuc2VydmljZSc7XG5cbmV4cG9ydCBjb25zdCBtZXRhRmFjdG9yeSA9ICgpID0+IG5ldyBNZXRhU3RhdGljTG9hZGVyKCk7XG5cbkBOZ01vZHVsZSgpXG5leHBvcnQgY2xhc3MgTWV0YU1vZHVsZSB7XG4gIHN0YXRpYyBmb3JSb290KFxuICAgIGNvbmZpZ3VyZWRQcm92aWRlcjogYW55ID0ge1xuICAgICAgcHJvdmlkZTogTWV0YUxvYWRlcixcbiAgICAgIHVzZUZhY3Rvcnk6IG1ldGFGYWN0b3J5XG4gICAgfVxuICApOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmdNb2R1bGU6IE1ldGFNb2R1bGUsXG4gICAgICBwcm92aWRlcnM6IFtjb25maWd1cmVkUHJvdmlkZXIsIE1ldGFHdWFyZCwgTWV0YVNlcnZpY2VdXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBTa2lwU2VsZigpIHBhcmVudE1vZHVsZT86IE1ldGFNb2R1bGUpIHtcbiAgICBpZiAocGFyZW50TW9kdWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNb2R1bGUgYWxyZWFkeSBsb2FkZWQ7IGltcG9ydCBpbiByb290IG1vZHVsZSBvbmx5LicpO1xuICAgIH1cbiAgfVxufVxuIl19
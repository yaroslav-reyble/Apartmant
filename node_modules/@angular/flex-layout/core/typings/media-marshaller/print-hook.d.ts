/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { OnDestroy } from '@angular/core';
import { MediaChange } from '../media-change';
import { BreakPoint } from '../breakpoints/break-point';
import { LayoutConfigOptions } from '../tokens/library-config';
import { BreakPointRegistry, OptionalBreakPoint } from '../breakpoints/break-point-registry';
/**
 * Interface to apply PrintHook to call anonymous `target.updateStyles()`
 */
import * as ɵngcc0 from '@angular/core';
export interface HookTarget {
    activatedBreakpoints: BreakPoint[];
    updateStyles(): void;
}
export declare const BREAKPOINT_PRINT: {
    alias: string;
    mediaQuery: string;
    priority: number;
};
/**
 * PrintHook - Use to intercept print MediaQuery activations and force
 *             layouts to render with the specified print alias/breakpoint
 *
 * Used in MediaMarshaller and MediaObserver
 */
export declare class PrintHook implements OnDestroy {
    protected breakpoints: BreakPointRegistry;
    protected layoutConfig: LayoutConfigOptions;
    protected _document: any;
    constructor(breakpoints: BreakPointRegistry, layoutConfig: LayoutConfigOptions, _document: any);
    /** Add 'print' mediaQuery: to listen for matchMedia activations */
    withPrintQuery(queries: string[]): string[];
    /** Is the MediaChange event for any 'print' @media */
    isPrintEvent(e: MediaChange): Boolean;
    /** What is the desired mqAlias to use while printing? */
    get printAlias(): string[];
    /** Lookup breakpoints associated with print aliases. */
    get printBreakPoints(): BreakPoint[];
    /** Lookup breakpoint associated with mediaQuery */
    getEventBreakpoints({ mediaQuery }: MediaChange): BreakPoint[];
    /** Update event with printAlias mediaQuery information */
    updateEvent(event: MediaChange): MediaChange;
    private registeredBeforeAfterPrintHooks;
    private isPrintingBeforeAfterEvent;
    private beforePrintEventListeners;
    private afterPrintEventListeners;
    private registerBeforeAfterPrintHooks;
    /**
     * Prepare RxJS filter operator with partial application
     * @return pipeable filter predicate
     */
    interceptEvents(target: HookTarget): (event: MediaChange) => void;
    /** Stop mediaChange event propagation in event streams */
    blockPropagation(): (event: MediaChange) => boolean;
    /**
     * Save current activateBreakpoints (for later restore)
     * and substitute only the printAlias breakpoint
     */
    protected startPrinting(target: HookTarget, bpList: OptionalBreakPoint[]): void;
    /** For any print de-activations, reset the entire print queue */
    protected stopPrinting(target: HookTarget): void;
    /**
     * To restore pre-Print Activations, we must capture the proper
     * list of breakpoint activations BEFORE print starts. OnBeforePrint()
     * is supported; so 'print' mediaQuery activations are used as a fallback
     * in browsers without `beforeprint` support.
     *
     * >  But activated breakpoints are deactivated BEFORE 'print' activation.
     *
     * Let's capture all de-activations using the following logic:
     *
     *  When not printing:
     *    - clear cache when activating non-print breakpoint
     *    - update cache (and sort) when deactivating
     *
     *  When printing:
     *    - sort and save when starting print
     *    - restore as activatedTargets and clear when stop printing
     */
    collectActivations(event: MediaChange): void;
    /** Teardown logic for the service. */
    ngOnDestroy(): void;
    /** Is this service currently in Print-mode ? */
    private isPrinting;
    private queue;
    private deactivations;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PrintHook>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJpbnQtaG9vay5kLnRzIiwic291cmNlcyI6WyJwcmludC1ob29rLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0RUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7IE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWVkaWFDaGFuZ2UgfSBmcm9tICcuLi9tZWRpYS1jaGFuZ2UnO1xuaW1wb3J0IHsgQnJlYWtQb2ludCB9IGZyb20gJy4uL2JyZWFrcG9pbnRzL2JyZWFrLXBvaW50JztcbmltcG9ydCB7IExheW91dENvbmZpZ09wdGlvbnMgfSBmcm9tICcuLi90b2tlbnMvbGlicmFyeS1jb25maWcnO1xuaW1wb3J0IHsgQnJlYWtQb2ludFJlZ2lzdHJ5LCBPcHRpb25hbEJyZWFrUG9pbnQgfSBmcm9tICcuLi9icmVha3BvaW50cy9icmVhay1wb2ludC1yZWdpc3RyeSc7XG4vKipcbiAqIEludGVyZmFjZSB0byBhcHBseSBQcmludEhvb2sgdG8gY2FsbCBhbm9ueW1vdXMgYHRhcmdldC51cGRhdGVTdHlsZXMoKWBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb29rVGFyZ2V0IHtcbiAgICBhY3RpdmF0ZWRCcmVha3BvaW50czogQnJlYWtQb2ludFtdO1xuICAgIHVwZGF0ZVN0eWxlcygpOiB2b2lkO1xufVxuZXhwb3J0IGRlY2xhcmUgY29uc3QgQlJFQUtQT0lOVF9QUklOVDoge1xuICAgIGFsaWFzOiBzdHJpbmc7XG4gICAgbWVkaWFRdWVyeTogc3RyaW5nO1xuICAgIHByaW9yaXR5OiBudW1iZXI7XG59O1xuLyoqXG4gKiBQcmludEhvb2sgLSBVc2UgdG8gaW50ZXJjZXB0IHByaW50IE1lZGlhUXVlcnkgYWN0aXZhdGlvbnMgYW5kIGZvcmNlXG4gKiAgICAgICAgICAgICBsYXlvdXRzIHRvIHJlbmRlciB3aXRoIHRoZSBzcGVjaWZpZWQgcHJpbnQgYWxpYXMvYnJlYWtwb2ludFxuICpcbiAqIFVzZWQgaW4gTWVkaWFNYXJzaGFsbGVyIGFuZCBNZWRpYU9ic2VydmVyXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFByaW50SG9vayBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gICAgcHJvdGVjdGVkIGJyZWFrcG9pbnRzOiBCcmVha1BvaW50UmVnaXN0cnk7XG4gICAgcHJvdGVjdGVkIGxheW91dENvbmZpZzogTGF5b3V0Q29uZmlnT3B0aW9ucztcbiAgICBwcm90ZWN0ZWQgX2RvY3VtZW50OiBhbnk7XG4gICAgY29uc3RydWN0b3IoYnJlYWtwb2ludHM6IEJyZWFrUG9pbnRSZWdpc3RyeSwgbGF5b3V0Q29uZmlnOiBMYXlvdXRDb25maWdPcHRpb25zLCBfZG9jdW1lbnQ6IGFueSk7XG4gICAgLyoqIEFkZCAncHJpbnQnIG1lZGlhUXVlcnk6IHRvIGxpc3RlbiBmb3IgbWF0Y2hNZWRpYSBhY3RpdmF0aW9ucyAqL1xuICAgIHdpdGhQcmludFF1ZXJ5KHF1ZXJpZXM6IHN0cmluZ1tdKTogc3RyaW5nW107XG4gICAgLyoqIElzIHRoZSBNZWRpYUNoYW5nZSBldmVudCBmb3IgYW55ICdwcmludCcgQG1lZGlhICovXG4gICAgaXNQcmludEV2ZW50KGU6IE1lZGlhQ2hhbmdlKTogQm9vbGVhbjtcbiAgICAvKiogV2hhdCBpcyB0aGUgZGVzaXJlZCBtcUFsaWFzIHRvIHVzZSB3aGlsZSBwcmludGluZz8gKi9cbiAgICBnZXQgcHJpbnRBbGlhcygpOiBzdHJpbmdbXTtcbiAgICAvKiogTG9va3VwIGJyZWFrcG9pbnRzIGFzc29jaWF0ZWQgd2l0aCBwcmludCBhbGlhc2VzLiAqL1xuICAgIGdldCBwcmludEJyZWFrUG9pbnRzKCk6IEJyZWFrUG9pbnRbXTtcbiAgICAvKiogTG9va3VwIGJyZWFrcG9pbnQgYXNzb2NpYXRlZCB3aXRoIG1lZGlhUXVlcnkgKi9cbiAgICBnZXRFdmVudEJyZWFrcG9pbnRzKHsgbWVkaWFRdWVyeSB9OiBNZWRpYUNoYW5nZSk6IEJyZWFrUG9pbnRbXTtcbiAgICAvKiogVXBkYXRlIGV2ZW50IHdpdGggcHJpbnRBbGlhcyBtZWRpYVF1ZXJ5IGluZm9ybWF0aW9uICovXG4gICAgdXBkYXRlRXZlbnQoZXZlbnQ6IE1lZGlhQ2hhbmdlKTogTWVkaWFDaGFuZ2U7XG4gICAgcHJpdmF0ZSByZWdpc3RlcmVkQmVmb3JlQWZ0ZXJQcmludEhvb2tzO1xuICAgIHByaXZhdGUgaXNQcmludGluZ0JlZm9yZUFmdGVyRXZlbnQ7XG4gICAgcHJpdmF0ZSBiZWZvcmVQcmludEV2ZW50TGlzdGVuZXJzO1xuICAgIHByaXZhdGUgYWZ0ZXJQcmludEV2ZW50TGlzdGVuZXJzO1xuICAgIHByaXZhdGUgcmVnaXN0ZXJCZWZvcmVBZnRlclByaW50SG9va3M7XG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBSeEpTIGZpbHRlciBvcGVyYXRvciB3aXRoIHBhcnRpYWwgYXBwbGljYXRpb25cbiAgICAgKiBAcmV0dXJuIHBpcGVhYmxlIGZpbHRlciBwcmVkaWNhdGVcbiAgICAgKi9cbiAgICBpbnRlcmNlcHRFdmVudHModGFyZ2V0OiBIb29rVGFyZ2V0KTogKGV2ZW50OiBNZWRpYUNoYW5nZSkgPT4gdm9pZDtcbiAgICAvKiogU3RvcCBtZWRpYUNoYW5nZSBldmVudCBwcm9wYWdhdGlvbiBpbiBldmVudCBzdHJlYW1zICovXG4gICAgYmxvY2tQcm9wYWdhdGlvbigpOiAoZXZlbnQ6IE1lZGlhQ2hhbmdlKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNhdmUgY3VycmVudCBhY3RpdmF0ZUJyZWFrcG9pbnRzIChmb3IgbGF0ZXIgcmVzdG9yZSlcbiAgICAgKiBhbmQgc3Vic3RpdHV0ZSBvbmx5IHRoZSBwcmludEFsaWFzIGJyZWFrcG9pbnRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RhcnRQcmludGluZyh0YXJnZXQ6IEhvb2tUYXJnZXQsIGJwTGlzdDogT3B0aW9uYWxCcmVha1BvaW50W10pOiB2b2lkO1xuICAgIC8qKiBGb3IgYW55IHByaW50IGRlLWFjdGl2YXRpb25zLCByZXNldCB0aGUgZW50aXJlIHByaW50IHF1ZXVlICovXG4gICAgcHJvdGVjdGVkIHN0b3BQcmludGluZyh0YXJnZXQ6IEhvb2tUYXJnZXQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRvIHJlc3RvcmUgcHJlLVByaW50IEFjdGl2YXRpb25zLCB3ZSBtdXN0IGNhcHR1cmUgdGhlIHByb3BlclxuICAgICAqIGxpc3Qgb2YgYnJlYWtwb2ludCBhY3RpdmF0aW9ucyBCRUZPUkUgcHJpbnQgc3RhcnRzLiBPbkJlZm9yZVByaW50KClcbiAgICAgKiBpcyBzdXBwb3J0ZWQ7IHNvICdwcmludCcgbWVkaWFRdWVyeSBhY3RpdmF0aW9ucyBhcmUgdXNlZCBhcyBhIGZhbGxiYWNrXG4gICAgICogaW4gYnJvd3NlcnMgd2l0aG91dCBgYmVmb3JlcHJpbnRgIHN1cHBvcnQuXG4gICAgICpcbiAgICAgKiA+ICBCdXQgYWN0aXZhdGVkIGJyZWFrcG9pbnRzIGFyZSBkZWFjdGl2YXRlZCBCRUZPUkUgJ3ByaW50JyBhY3RpdmF0aW9uLlxuICAgICAqXG4gICAgICogTGV0J3MgY2FwdHVyZSBhbGwgZGUtYWN0aXZhdGlvbnMgdXNpbmcgdGhlIGZvbGxvd2luZyBsb2dpYzpcbiAgICAgKlxuICAgICAqICBXaGVuIG5vdCBwcmludGluZzpcbiAgICAgKiAgICAtIGNsZWFyIGNhY2hlIHdoZW4gYWN0aXZhdGluZyBub24tcHJpbnQgYnJlYWtwb2ludFxuICAgICAqICAgIC0gdXBkYXRlIGNhY2hlIChhbmQgc29ydCkgd2hlbiBkZWFjdGl2YXRpbmdcbiAgICAgKlxuICAgICAqICBXaGVuIHByaW50aW5nOlxuICAgICAqICAgIC0gc29ydCBhbmQgc2F2ZSB3aGVuIHN0YXJ0aW5nIHByaW50XG4gICAgICogICAgLSByZXN0b3JlIGFzIGFjdGl2YXRlZFRhcmdldHMgYW5kIGNsZWFyIHdoZW4gc3RvcCBwcmludGluZ1xuICAgICAqL1xuICAgIGNvbGxlY3RBY3RpdmF0aW9ucyhldmVudDogTWVkaWFDaGFuZ2UpOiB2b2lkO1xuICAgIC8qKiBUZWFyZG93biBsb2dpYyBmb3IgdGhlIHNlcnZpY2UuICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKiogSXMgdGhpcyBzZXJ2aWNlIGN1cnJlbnRseSBpbiBQcmludC1tb2RlID8gKi9cbiAgICBwcml2YXRlIGlzUHJpbnRpbmc7XG4gICAgcHJpdmF0ZSBxdWV1ZTtcbiAgICBwcml2YXRlIGRlYWN0aXZhdGlvbnM7XG59XG4iXX0=